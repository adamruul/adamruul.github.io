<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Adam Ruul</title>
    <link>https://adamruul.github.io/</link>
    <description>Recent content on Adam Ruul</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 08 Nov 2016 17:58:22 +0100</lastBuildDate>
    <atom:link href="https://adamruul.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Solving the Spotify Labs Puzzles with Erlang</title>
      <link>https://adamruul.github.io/post/spotify-puzzles-erlang/</link>
      <pubDate>Tue, 08 Nov 2016 17:58:22 +0100</pubDate>
      
      <guid>https://adamruul.github.io/post/spotify-puzzles-erlang/</guid>
      <description>

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#reversed-binary-numbers&#34;&gt;Reversed Binary Numbers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#zipf-s-song&#34;&gt;Zipf&amp;rsquo;s Song&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Lately, I&amp;rsquo;ve been freshening up on my forgotten Erlang skills. To do so, I tried solving two of the &lt;a href=&#34;https://labs.spotify.com/puzzles/&#34;&gt;puzzles posted by Spotify Labs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The source code for the solutions can be found in this &lt;a href=&#34;https://github.com/adamruul/Spotify_Puzzles&#34;&gt;repository&lt;/a&gt;. The solutions does not support the stdin/stdout requierment that was stated, nor is Erlang a valid language to officially submit a solution in. I solved the puzzles mostly because they are great puzzles to solve when trying to learn a new language (Erlang in my case).&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;reversed-binary-numbers&#34;&gt;Reversed Binary Numbers&lt;/h2&gt;

&lt;p&gt;So this puzzle is a typical &amp;ldquo;reverse-a-string&amp;rdquo;-puzzle &amp;ndash;  &lt;em&gt;with some twists&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;First of all we need to calculate the binary representation of the input number.
One common pitfall is to convert the input number into a fixed bit binary number (eg: 8bit binary number). For smaller inputs, you&amp;rsquo;ll end up with padding zeros for the MSBs. Reversing this will result in the wrong reversed value.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WRONG:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Decimal: 4
Binary(8bit): 00000100
Reversed Binary: 00100000
Decimal Result: 32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;CORRECT:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Decimal: 4
Binary: 100
Reversed Binary: 001
Decimal Result: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Erlang we have the nifty functions &lt;code&gt;integer_to_list/2&lt;/code&gt; and &lt;code&gt;list_to_integer/2&lt;/code&gt;, taking two arguments: An integer respectively A List/String, and a Base. Using these functions with base 2 will convert a decimal number into its binary (non-zero-padded) representation, and convert it back to its decimal representation. Once we&amp;rsquo;ve converted the decimal number into its binary representation, we can just use &lt;code&gt;lists:reverse/1&lt;/code&gt; to reverse the binary number, before converting it back to its decimal representation.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;code&#34;&gt;Code&lt;/h3&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000&#34;&gt;binary_reverse&lt;/span&gt;(&lt;span style=&#34;color: #000000&#34;&gt;Integer&lt;/span&gt;) &lt;span style=&#34;color: #000000&#34;&gt;-&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #000000&#34;&gt;binary_reverse&lt;/span&gt;(&lt;span style=&#34;color: #000000&#34;&gt;Integer&lt;/span&gt;,&lt;span style=&#34;color: #1C01CE&#34;&gt;2&lt;/span&gt;).

&lt;span style=&#34;color: #000000&#34;&gt;binary_reverse&lt;/span&gt;(&lt;span style=&#34;color: #000000&#34;&gt;Integer&lt;/span&gt;,&lt;span style=&#34;color: #000000&#34;&gt;Base&lt;/span&gt;) &lt;span style=&#34;color: #000000&#34;&gt;-&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color: #A90D91&#34;&gt;list_to_integer&lt;/span&gt;(
		&lt;span style=&#34;color: #000000&#34;&gt;lists&lt;/span&gt;:&lt;span style=&#34;color: #000000&#34;&gt;reverse&lt;/span&gt;(
			&lt;span style=&#34;color: #A90D91&#34;&gt;integer_to_list&lt;/span&gt;(&lt;span style=&#34;color: #000000&#34;&gt;Integer&lt;/span&gt;,&lt;span style=&#34;color: #000000&#34;&gt;Base&lt;/span&gt;)),&lt;span style=&#34;color: #000000&#34;&gt;Base&lt;/span&gt;).
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;

&lt;h2 id=&#34;zipf-s-song&#34;&gt;Zipf&amp;rsquo;s Song&lt;/h2&gt;

&lt;p&gt;In this puzzle, we first need to assign a score to each track of the album using the number of plays and the &amp;ldquo;Zipf score&amp;rdquo;.
Zipf&amp;rsquo;s law says that the frequency of the &lt;code&gt;i&lt;/code&gt;&amp;lsquo;th most common object shold be proportional to &lt;code&gt;1/i&lt;/code&gt;. In our context, the most common song on a album will be the first song (track 1) and the least common song will be the last song on the album (track &lt;code&gt;n&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;So to define the quality of the song using Zipf&amp;rsquo;s Law, we&amp;rsquo;ll need to multiply the number of plays for each track with how &amp;ldquo;common&amp;rdquo; the track is (the track position on the album).&lt;/p&gt;

&lt;p&gt;This will result in:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Score(Track 1) = NR_PLAYS(Track 1) * 1
Score(Track 2) = NR_PLAYS(Track 2) * 2
Score(Track 3) = NR_PLAYS(Track 3) * 3
.
.
.
Score(Track n) = NR_PLAYS(Track n) * n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So to solve the puzzle, we just need to multiply each track&amp;rsquo;s play-count with its position. Then we just filter out the &lt;code&gt;m&lt;/code&gt; highest scoring tracks.&lt;/p&gt;

&lt;h3 id=&#34;code-1&#34;&gt;Code&lt;/h3&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000&#34;&gt;zipf_prop&lt;/span&gt;(&lt;span style=&#34;color: #000000&#34;&gt;List&lt;/span&gt;) &lt;span style=&#34;color: #000000&#34;&gt;-&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color: #000000&#34;&gt;Indexed&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;=&lt;/span&gt; [{&lt;span style=&#34;color: #000000&#34;&gt;lists&lt;/span&gt;:&lt;span style=&#34;color: #000000&#34;&gt;nth&lt;/span&gt;(&lt;span style=&#34;color: #000000&#34;&gt;C&lt;/span&gt;,&lt;span style=&#34;color: #000000&#34;&gt;List&lt;/span&gt;),&lt;span style=&#34;color: #000000&#34;&gt;C&lt;/span&gt;} || &lt;span style=&#34;color: #000000&#34;&gt;C&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;lists&lt;/span&gt;:&lt;span style=&#34;color: #000000&#34;&gt;seq&lt;/span&gt;(&lt;span style=&#34;color: #1C01CE&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color: #A90D91&#34;&gt;length&lt;/span&gt;(&lt;span style=&#34;color: #000000&#34;&gt;List&lt;/span&gt;))],
	[{&lt;span style=&#34;color: #000000&#34;&gt;I&lt;/span&gt;,&lt;span style=&#34;color: #000000&#34;&gt;Tr&lt;/span&gt;} || {{_,&lt;span style=&#34;color: #000000&#34;&gt;Tr&lt;/span&gt;},&lt;span style=&#34;color: #000000&#34;&gt;I&lt;/span&gt;} &lt;span style=&#34;color: #000000&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;Indexed&lt;/span&gt;].

&lt;span style=&#34;color: #000000&#34;&gt;zipf_songs&lt;/span&gt;(&lt;span style=&#34;color: #000000&#34;&gt;Album&lt;/span&gt;,&lt;span style=&#34;color: #000000&#34;&gt;N&lt;/span&gt;,&lt;span style=&#34;color: #000000&#34;&gt;M&lt;/span&gt;) &lt;span style=&#34;color: #000000&#34;&gt;-&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color: #000000&#34;&gt;S&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;lists&lt;/span&gt;:&lt;span style=&#34;color: #000000&#34;&gt;zip&lt;/span&gt;(&lt;span style=&#34;color: #000000&#34;&gt;Album&lt;/span&gt;,&lt;span style=&#34;color: #000000&#34;&gt;zipf_prop&lt;/span&gt;(&lt;span style=&#34;color: #000000&#34;&gt;Album&lt;/span&gt;)), &lt;span style=&#34;color: #177500&#34;&gt;% add index to each track&lt;/span&gt;
	&lt;span style=&#34;color: #000000&#34;&gt;Score&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;=&lt;/span&gt; [{&lt;span style=&#34;color: #000000&#34;&gt;Track&lt;/span&gt;, &lt;span style=&#34;color: #000000&#34;&gt;Plays&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;Prop&lt;/span&gt;} || {{&lt;span style=&#34;color: #000000&#34;&gt;Plays&lt;/span&gt;,&lt;span style=&#34;color: #000000&#34;&gt;Track&lt;/span&gt;},{&lt;span style=&#34;color: #000000&#34;&gt;Prop&lt;/span&gt;,_}} &lt;span style=&#34;color: #000000&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;S&lt;/span&gt; ], &lt;span style=&#34;color: #177500&#34;&gt;% multiply nr of plays with how common the track is (index).&lt;/span&gt;
	&lt;span style=&#34;color: #000000&#34;&gt;TupleSort&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #A90D91&#34;&gt;fun&lt;/span&gt;({&lt;span style=&#34;color: #000000&#34;&gt;KeyA&lt;/span&gt;,&lt;span style=&#34;color: #000000&#34;&gt;ValA&lt;/span&gt;}, {&lt;span style=&#34;color: #000000&#34;&gt;KeyB&lt;/span&gt;,&lt;span style=&#34;color: #000000&#34;&gt;ValB&lt;/span&gt;}) &lt;span style=&#34;color: #000000&#34;&gt;-&amp;gt;&lt;/span&gt; {&lt;span style=&#34;color: #000000&#34;&gt;ValA&lt;/span&gt;,&lt;span style=&#34;color: #000000&#34;&gt;KeyA&lt;/span&gt;} &lt;span style=&#34;color: #000000&#34;&gt;=&amp;lt;&lt;/span&gt; {&lt;span style=&#34;color: #000000&#34;&gt;ValB&lt;/span&gt;,&lt;span style=&#34;color: #000000&#34;&gt;KeyB&lt;/span&gt;} &lt;span style=&#34;color: #A90D91&#34;&gt;end&lt;/span&gt;, &lt;span style=&#34;color: #177500&#34;&gt;% just a help-function for sorting tuples.&lt;/span&gt;
	&lt;span style=&#34;color: #000000&#34;&gt;MostPopular&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;lists&lt;/span&gt;:&lt;span style=&#34;color: #000000&#34;&gt;nthtail&lt;/span&gt;(&lt;span style=&#34;color: #000000&#34;&gt;N-M&lt;/span&gt;, &lt;span style=&#34;color: #000000&#34;&gt;lists&lt;/span&gt;:&lt;span style=&#34;color: #000000&#34;&gt;sort&lt;/span&gt;(&lt;span style=&#34;color: #000000&#34;&gt;TupleSort&lt;/span&gt;, &lt;span style=&#34;color: #000000&#34;&gt;Score&lt;/span&gt;)), &lt;span style=&#34;color: #177500&#34;&gt;% Sort the list and grab the M most popular songs.&lt;/span&gt;
	[&lt;span style=&#34;color: #000000&#34;&gt;Track&lt;/span&gt; || {&lt;span style=&#34;color: #000000&#34;&gt;Track&lt;/span&gt;,_} &lt;span style=&#34;color: #000000&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;lists&lt;/span&gt;:&lt;span style=&#34;color: #000000&#34;&gt;reverse&lt;/span&gt;(&lt;span style=&#34;color: #000000&#34;&gt;MostPopular&lt;/span&gt;)].  &lt;span style=&#34;color: #177500&#34;&gt;% Make the list descending and remove the score.&lt;/span&gt;


&lt;span style=&#34;color: #177500&#34;&gt;% Example Usage:&lt;/span&gt;
&lt;span style=&#34;color: #000000&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #1C01CE&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color: #177500&#34;&gt;% number of tracks on album&lt;/span&gt;
&lt;span style=&#34;color: #000000&#34;&gt;M&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #1C01CE&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color: #177500&#34;&gt;% number of top-tracks to find.&lt;/span&gt;
&lt;span style=&#34;color: #000000&#34;&gt;Album&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;=&lt;/span&gt; [{&lt;span style=&#34;color: #1C01CE&#34;&gt;30&lt;/span&gt;,&lt;span style=&#34;color: #C41A16&#34;&gt;&amp;quot;one&amp;quot;&lt;/span&gt;},{&lt;span style=&#34;color: #1C01CE&#34;&gt;30&lt;/span&gt;,&lt;span style=&#34;color: #C41A16&#34;&gt;&amp;quot;two&amp;quot;&lt;/span&gt;},{&lt;span style=&#34;color: #1C01CE&#34;&gt;15&lt;/span&gt;,&lt;span style=&#34;color: #C41A16&#34;&gt;&amp;quot;three&amp;quot;&lt;/span&gt;},{&lt;span style=&#34;color: #1C01CE&#34;&gt;25&lt;/span&gt;,&lt;span style=&#34;color: #C41A16&#34;&gt;&amp;quot;four&amp;quot;&lt;/span&gt;}], &lt;span style=&#34;color: #177500&#34;&gt;% Input album formatted as: {Nr_Plays, Track_Name}&lt;/span&gt;
&lt;span style=&#34;color: #000000&#34;&gt;Result&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;zipf_songs&lt;/span&gt;(&lt;span style=&#34;color: #000000&#34;&gt;Album&lt;/span&gt;,&lt;span style=&#34;color: #000000&#34;&gt;N&lt;/span&gt;,&lt;span style=&#34;color: #000000&#34;&gt;M&lt;/span&gt;),
&lt;span style=&#34;color: #000000&#34;&gt;lists&lt;/span&gt;:&lt;span style=&#34;color: #000000&#34;&gt;map&lt;/span&gt;(&lt;span style=&#34;color: #A90D91&#34;&gt;fun&lt;/span&gt;(&lt;span style=&#34;color: #000000&#34;&gt;X&lt;/span&gt;) &lt;span style=&#34;color: #000000&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;io&lt;/span&gt;:&lt;span style=&#34;color: #000000&#34;&gt;format&lt;/span&gt;(&lt;span style=&#34;color: #C41A16&#34;&gt;&amp;quot;~p~n&amp;quot;&lt;/span&gt;,[&lt;span style=&#34;color: #000000&#34;&gt;X&lt;/span&gt;]) &lt;span style=&#34;color: #A90D91&#34;&gt;end&lt;/span&gt;, &lt;span style=&#34;color: #000000&#34;&gt;Result&lt;/span&gt;), &lt;span style=&#34;color: #177500&#34;&gt;% print result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Temperature-based Wireless Communication</title>
      <link>https://adamruul.github.io/post/sendor-nodes/</link>
      <pubDate>Thu, 29 Sep 2016 20:14:20 +0200</pubDate>
      
      <guid>https://adamruul.github.io/post/sendor-nodes/</guid>
      <description>

&lt;p&gt;This project is a prototype used for investigating the feasibility of communicating with sensor nodes using controlled temperature fluctuations. Using temperature fluctuations for wireless communication, could potentially have multiple benefits. Compared to electromagnetic waves, temperature fluctuations could provide more secure wireless communication. Also, temperature fluctuation-based communication could enable devices without hardware for wireless communication for the IoT. The prototype system is capable of sending bytes using temperature fluctuations that will be interpreted as ASCII-characters, at a rate of 0.25 bit/s and at a distance of 2 meters (without any bit errors). The low bitrate is mostly due to limitations of how fast the lamp could be dimmed.&lt;/p&gt;

&lt;p&gt;The prototype system consist of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Genuino 101 board&lt;/li&gt;
&lt;li&gt;Beurer IL 11 Infrared lamp&lt;/li&gt;
&lt;li&gt;Everspring dimmer (a ZWave based dimmer)&lt;/li&gt;
&lt;li&gt;Aeotec Z-Stick Series 2 (a dongle used for communicating with the dimmer)&lt;/li&gt;
&lt;li&gt;Adafruit BMP280-temperature sensor&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;demo-video&#34;&gt;Demo Video&lt;/h2&gt;

&lt;p&gt;To the left you can see the system in action, In the middle you can see the terminal for the transmitting node, and to the right we have the console for the receiving node.&lt;/p&gt;

&lt;p&gt;In the video below, we can see the transmitter first idling for a while, before sending a initialization sequence &lt;code&gt;1,0,0,0,0,0,0,1&lt;/code&gt; followed by the message &lt;code&gt;&amp;quot;Hej&amp;quot;&lt;/code&gt;, and finally send an end-transmission sequence &lt;code&gt;0,0,0,0,0,1,0,0&lt;/code&gt;&lt;/p&gt;

&lt;iframe width=&#34;100%&#34; height=&#34;400px&#34; src=&#34;https://www.youtube.com/embed/pYIxn5YdeSc&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
  </channel>
</rss>